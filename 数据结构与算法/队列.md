##   队列

### 队列例题

#### 两个栈实现一个队列

​	**Question1：仅使用两个栈实现一个先入先出的队列，并支持普通队列的全部四种操作（`push`、`top`、`pop` 和 `empty`）**

​	栈的特点为后进先出，元素出栈顺序与入栈时相反；队列为先进先出，出队顺序与入队顺序相同。栈经两次入栈出栈操作就与队列同序d。

![image-20241023160510166](C:/Users/Yeqiu/AppData/Roaming/Typora/typora-user-images/image-20241023160510166.png)
	入栈时都将数据存入栈s1中；
	执行访问栈顶元素时，就将s1中的元素依次出栈再入栈到s2中，此后访问队列中元素时就访问s2的栈顶元素，直到s2中为空时就再将s1中元素导入s2中；
	判断队列是否为空就判断两个栈是否同时为空。



_源码_

~~~cpp
#include <stack>
class MyQueue {
private:
    stack<int>* s1;
	stack<int>* s2;

private:
    void move()
    {
		while(!s1->empty())
        {
            s2->push(s1->top());
            s1->pop();
        }
    }
    
public:
    MyQueue() {
        s1 = new stack<int>;
        s2 = new stack<int>;
    }
    ~MyQueue()
    {
		delete s1;
        delete s2;
        s1 = s2 = nullptr;
    }
    void push(int x) {
       	s1->push(x);
    }
    
    int pop() {
        if(empty())
       		throw "quene is empty";
        if(s2->empty())
            move();
        int ret = s2->top();
        s2->pop();
        return ret;
    }
    
    int peek() {
       	if(s2->empty())
            move();
        return s2->top();
    }
    
    bool empty() {
        return s1->empty() && s2->empty();
    }
};
~~~



​	**Question2：仅使用两个队列实现一个后入先出的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）**

​	队列不能通过简单的出队入队操作就与栈同序。可以在元素入队时调整元素顺序与栈同序	入队时固定向空的队列p入队，再将已经调整为逆序的队列q中的元素依次入队到p中，此时p是逆序队列，q是空队列，将p，q互换；
​	访问操作时访问p的队头元素；
​	p中元素为空，则栈为空。

![image-20241023164825246](C:/Users/Yeqiu/AppData/Roaming/Typora/typora-user-images/image-20241023164825246.png)

_源码_

~~~cpp
#include<queue>
class MyStack {
private:
    queue<int> *p;//入栈队列
	queue<int> *q;//调序队列
public:
    MyStack() {
        p = new queue<int>;
        q = new queue<int>;
    }
    
    ~MyStack(){
        delete p;
        delete q;
        p = q = nullptr;
    }
    
    void push(int x) {
        p->push(x);
        while(!q->empty())
        {
            p->push(q->front());
            q->pop();
        }
       	queue<int> *tmp = p;
        p = q;
        q = tmp;
    }
    
    int pop() {
        int ret = q->front();
        q->pop();
        return ret;
    }
    
    int top() {
        return q->front();
    }
    
    bool empty() {
        return q->empty();
    }
};
~~~



---

