## 二分搜索算法

​	当数组中的元素有序时，二分搜索能够更快的找到目标元素
​		线性搜索：逐个遍历，时间复杂度为O(n);
​		二分搜索：每次排除一半的元素，时间复杂度为O(logn)。

###	二分搜索实现

​	定义_left_为数组首元素的索引，_right_为数组末尾元素的索引，_mid_是_left_和_right_之间的中位元素索引，_mid = (letf + right) / 2_。
​	![image-20241023172221358](C:\Users\Yeqiu\AppData\Roaming\Typora\typora-user-images\image-20241023172221358.png)

​	判断_arr[mid]_的值与搜索值_val_的大小
​		若_arr[mid] > val_，说明_mid_往后的元素都大于_val_，舍去区间[_mid,right_]的元素。
​		若_arr[mid] < val_，说明_mid_往前的元素都大于_val_，舍去区间[_left,right_]的元素。
​		若_arr[mid] = val_，说明下标为mid的元素就是搜索目标_val_。
​		当_letf > rigtht_时，数组中不存在值为_val_的元素

_arr[mid] > val_

![image-20241023173413836](C:\Users\Yeqiu\AppData\Roaming\Typora\typora-user-images\image-20241023173413836.png)

_arr[mid] < val_

![image-20241023173510903](C:\Users\Yeqiu\AppData\Roaming\Typora\typora-user-images\image-20241023173510903.png)

_源码_

~~~cpp
int BinarySearch(int arr[], int size,int val)	//返回数组下标
{
    int left = 0, right = size - 1;
    while(left <=       rutthgt 我   right)
    {
		int mid = (left + right) / 2;
        if(arr[mid] > val)
        {
			right = mid - 1;
        }
        else if(arr[mid] < val)
        {
			left = mid + 1;
        }
        else if(arr[mid] == right)
            return mid;
	}
    
	return -1；	//返回-1，该数组中没有值为val的元素
}
~~~

