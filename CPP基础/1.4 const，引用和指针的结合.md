## 第二节 const，引用和指针的结合



### 引用

​	引用是一个变量的别名，操作该别名就是操作该变量。

#### 引用的定义

~~~cpp
<typename> & [ReferenceName] = [VariableName];

int a = 0;
int &ra = a;
~~~

#### 引用与指针的异同

##### 相似点：
​	引用与指针的实现方式相同

_指针定义及其汇编指令_

~~~cpp
int a = 10;
int *pa = &a;
//	lea eax,[a]
//	mov dword ptr[pa],eax
~~~

_引用定义及其汇编指令_

~~~cpp
int a = 10;
int &ra = a;
//	lea eax,[a];
//	mov dword ptr[pa],eax
~~~

​	可以看到不论指针的定义还是引用的定义都是先取出a的地址，再将a的地址存入引用变量或指针变量中
​	引用可以被视为自带解引用的 _\*const_ 指针

~~~cpp
int &ra = a;
// =>
int *const pa = &a;
~~~

​	对于复杂对象的引用可以先将其指针形式写出，然后用'&' 取代'\*'

~~~cpp
int arr[5];
int (*)parr[5] = &arr;	//数组指针
int (&)rarr[5] = arr;	//数组的引用
~~~

​	a，ra，\*pa访问的是同一块内存，三者中任一修改该内存的值其余二者也随之变化。
例如：

~~~cpp
sizeof(*parr);
sizeof(rarr);
sizeof(arr);
~~~

​	它们的值都是5\*sizeof(int)

##### 不同点：

​	引用不存在空引用，引用必须连接到一块合法的内存。
​	引用一旦被初始化为一个对象，就不能够再被指向另一个对象。指针可以随时更改
​	引用必须在创建时被初始化。指针可以在任意时候初始化。

#### 左值引用与右值引用

​	左值：有内存，有名字，值可以修改
​	右值：没内存，没名字

##### 左值引用

~~~cpp
int a = 1;		//a是一个左值
int &ra = a;	//左值可以作为引用的对象
//int rb = 10;	//error 10是一个右值，右值不能被直接引用
~~~

​	左值引用的对象只能是左值

##### 右值引用_(c++11)_

~~~cpp
int &&ra = 10;
//或者使用
int const &ra = 10;
//	mov dword ptr[ebp-30h], 14h	//ebp-30是一个临时变量
//	lea eax[ebp-30h]
//	mov ptr[ra], eax
~~~

​	右值引用通过产生一个临时变量储存右值，再引用这个临时变量实现。
​	右值引用只能引用右值。
​	右值引用本身是一个左值。

### const用法

​	const修饰变量不能做为左值