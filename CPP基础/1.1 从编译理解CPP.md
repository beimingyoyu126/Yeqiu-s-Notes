## 从编译理解CPP

### 虚拟地址空间划分

​	任何编程语言最终都会把代码转化为指令和数据，c和cpp最终会生成一个 xxx.exe 文件或 xxx.out 文件，将该文件加载到内存以运行程序。
​	在 x86Linux 中，系统会为当前进程分配 4G 大小的虚拟地址空间(x64 平台是 4E)。虚拟内存的分配如图所示：
​	![image-20241018171626469](C:\Users\Yeqiu\AppData\Roaming\Typora\typora-user-images\image-20241018171626469.png)

​	**.text 代码段**：存放运行时的代码
​	**.rodata 只读数据段**：存放只读变量，内容不可修改。如常量字符串char*p = "hello"
​	**.data 数据段**：存放初始化的变量
​	**.bss 数据段**：存放未初始化的变量或者初始化为零的变量，.bss段变量默认以0作为初始值
​	**.heap 堆**：只有程序在动态内存开辟(new, malloc)才会分配内存，<u>**堆内存从低地址到高**地址增长空间</u>
​	**加载共享库(动态链接库)**：.dll(Win dows) .so(Linux) 
​	**.stack 栈**：函数运行，进程私有空间，<u>**栈空间高地址到低地址增长**</u>
​	**命令行参数和环境变量**：如IP地址，端口号，文件路径...
​	**内核空间**：存放操作系统相关的代码和数据。每个进程的用户空间是私有的，内核空间是共享的

​	文件 main.cpp

~~~cpp
#include <iostream>
#include <test.h>
using namespace std;

int gdata1 = 10;		//.data
int gdata2 = 0;			//.bss
int gdata3;				//.bss

static int gdata4 = 11;	//.data
static int gdata5 = 0;	//.bss
static int gdata6;		//.bss

int mian()
{
	int a = 12;			//mov dword ptr[a], 0Ch
    int b = 0;			//mov dword ptr[b], 0
    int c;				
    
    static int e = 13;
    static int f = 0;
    static int g;
}
~~~

​	**全局的变量都被存放在数据段。**
​	**局部变量直接生成指令因此存放在代码段。**
​	**全局静态变量和局部静态变量都被存放在数据段。**





---



### 函数调用过程

​	运行代码：

```cpp
int sum(int fa, int fb)
{
	int temp = 0;
    temp = a + b;
    return temp;    
}

int main()
{
	int a = 10;
    int b = 20;
    int ret = sum(a,b);
    cout << "ret:" << ret << endl;
    return 0;
}
```

​	把上述代码非为三个部分分析：
​	main函数中初始化部分：在函数中有两个重要指针**esp**(_栈顶_)和**ebp**(_栈底_)，分别指向栈顶和栈底位置，这中间的空间就是函数的栈帧，函数的内容如函数内的局部变量就储存在此处。

```cpp
	int a = 10;
//	mov dword ptr[ebp - 4], 0Ah
    int b = 20;
//	mov dword ptr[ebp - 8], 14h
```

​	因为变量a，b是局部变量不会产生符号，所以直接生成指令
​	

![image-20241019181452085](C:\Users\Yeqiu\AppData\Roaming\Typora\typora-user-images\image-20241019181452085.png)

	#### 调用前准备部分
​	首先将参数表从**右至左压栈**，_压栈操作就是对函数参数的赋值_。esp也随着函数参数压栈向低地址移动，参数都压栈后esp指向函数参数的下一个位置的地址

~~~cpp
int resault = sum(a, b);
//	参数压栈
//	mov eax, dword ptr[ebp - 08h]	将b的值存放到寄存器eax
//	push eax						将eax即b的值压栈
//	mov ecx, dword ptr[ebp - 04h]	将a的值存放到寄存器ecx
//	push ecx						将a压栈

//	重要部分 函数调用
//	call sum
//	add esp, 8
//	mov dword ptr[ebp - 0Ch], eax
~~~



![image-20241019232118364](C:\Users\Yeqiu\AppData\Roaming\Typora\typora-user-images\image-20241019232118364.png)

	#### call指令调用函数
​	call会将下一行的代码的地址入栈，然后进入函数

![image-20241019232023875](C:\Users\Yeqiu\AppData\Roaming\Typora\typora-user-images\image-20241019232023875.png)

​	进入函数时最先执行的是为sum函数开辟栈帧，若是再vs中编译还会为开辟的栈帧进行初始化，将每个单元格初始为0xcc
~~~cpp
int sum(int fa, int fb)
{
//	push ebp		将main函数中的ebp位置入栈（push时ebp也会移动）
//	mov ebp, esp	将ebp移到esp作为调用函数的栈底
//	sub esp，0CCh	为sum函数开辟栈帧大小为0CCh
//	仅VS中
//	rep stos		相当于for 对每个单元初始化
    
    int tmp = 0;
//	mov dword [ebp - 04h], 0
	tmp = a + b;
//	mov eax, dword ptr[ebp + 0Ch]	存fb的值
//	add eax, dword ptr[ebp + 8]		加等于a的值
//	mov dword ptr[ebp - 4], eax
	return tmp;
//	mov eax, ptr[ebp - 4], eax     
}

~~~

![image-20241019231916283](C:\Users\Yeqiu\AppData\Roaming\Typora\typora-user-images\image-20241019231916283.png)

	#### 函数回退过程
​	函数回退时先将ebp的地址赋值给esp，再将此时栈顶元素_（main函数中ebp的位置）_出栈并将出栈元素赋值给ebp，ebp便回到了main函数的栈底处，执行ret指令。ret指令先将此时栈顶元素出栈_（call sum的下一行指令 add esp, 8的地址）_存放到cpu的pc寄存器，以告诉计算机运算下一行代码的位置。此时esp已经回到了main函数原本的栈顶位置。

~~~cpp	
int sum(int fa, int fb)
{
	int tmp = 0;
    tmp = a + b;
    return tmp;    
}
//	mov esp,ebp
// 	pop ebp
//	ret
~~~

![image-20241019231712774](C:\Users\Yeqiu\AppData\Roaming\Typora\typora-user-images\image-20241019231712774.png)

	#### 小结提问
​	**Q1：main函数调用sum，sum执行完以后如何知道回到哪个函数？**
​	答：

​	**Q2：sum函数执行完回到调用方怎么知道执行哪一条语句继续运行程序？**
​	答：



---



### 编译链接原理

​	源文件
_main.cpp_

~~~cpp
extern int data;
int sum(int x, int y);
int data = 10;

int mian()
{
	int a = gdata;
    int b = data;
    int ret = sum(a, b);
    
    return 0;
}
~~~

_sum.cpp_

~~~cpp
int gdata = 10;

int sum(int a, int b)
{
	return a + b;
}
~~~

#### 编译阶段

​	所有的.c或.cpp文件都是单独编译成对应的二进制可重定向目标文件_（.obj文件）_，然后交给链接器将多个.obj文件整合构成一个二进制可执行程序_（xxx.exe或者a.out)_。

​	整个编译过程分为三步：

![image-20241020104549108](C:\Users\Yeqiu\AppData\Roaming\Typora\typora-user-images\image-20241020104549108.png)

##### 预编译

​	通过修改源文件文本内容，处理一些#预处理指令，如文件包含、宏、条件编译。
​	需注意并非所有#开头指令都是预处理指令，如：

~~~cpp
#pragma lib		//指定链接库
#pragma link	//更改程序入口
~~~

​	这两条指令都是在链接时处理的

	##### 编译
​	编译阶段进行语法分析、词法分析和语义分析。将代码优化后产生相应的汇编代码文件_（.s文件）_。

##### 汇编

​	使用不同平台_（linux和windows）_的汇编器将.s文件翻译成二进制机器码，生成二进制可重定向目标文件。
​	编译完成后生成的.o文件是一个由不同代码段组成的段表，编译时代码产生的符号按类别被储存在对应类别代码段中。

代码段的组成：
	.text段：储存编译后的指令
	.rodata  .data  .bss 数据段：存放全局变量和静态变量
	**.symtab 符号表**：存放函数和变量的名称和地址链接器以此解析符号引用_(UND)_
	.section table 段表

​	编译阶段的符号不分配虚拟地址，.o文件.text中的指令也没有地址。

![image-20241020110215455](C:\Users\Yeqiu\AppData\Roaming\Typora\typora-user-images\image-20241020110215455.png)

\*UND\* _(undefine)_ 引用，未在文件中定义的函数声明或变量声明就会被处理为 \*UND\* 引用，位于符号表中

![image-20241020110330282](C:\Users\Yeqiu\AppData\Roaming\Typora\typora-user-images\image-20241020110330282.png)



#### 链接阶段

![image-20241020115414094](C:\Users\Yeqiu\AppData\Roaming\Typora\typora-user-images\image-20241020115414094.png)

​	链接分为两步：

##### 各段合并

​	编译完成后有多个.o文件，静态库文件_(\*.a  \*.lib）_,每个文件都有自己的段表，链接器就对每个文件的各个代码段进行合并。
​	**符号表和并**：<u>符号合并时会进行符号解析，所有引用的符号都必须找到符号定义。若未能找到符号定义会发生_符号未定义错误_。若是找到多个定义，会发生_符号重定义错误_。</u>



##### 符号重定向（重定位）

​	符号表解析成功后，给所有符号分配地址，并把符号分配的地址写入指令中

#### 二进制可执行文件

​	链接完成产生的文件就是二进制可执行文件_(.exe, a.out)_。二进制可执行文件也是段落结构

![image-20241024094524409](C:/Users/Yeqiu/AppData/Roaming/Typora/typora-user-images/image-20241024094524409.png)

相较于.o文件：
	可执行文件的文件头记录着程序入口地址_(main函数地址)_以及其他运行信息	
	可执行文件额外拥有一个program headers段，program headers段中有两个load告诉编译器程序运行时加载到内存的部分，其一为代码段，其二为数据段。

![image-20241024094922467](C:/Users/Yeqiu/AppData/Roaming/Typora/typora-user-images/image-20241024094922467.png)

​	将加载的内容_(.text, .rodata, .data, .bss...)_映射到进程分配的虚拟地址的对应部分_(.text, .rodata, .data, .bss...)_程序便可以运行。

#### 小结提问

​	Question1：符号什么时候分配内存？

​	Question2：可执行文件组成格式是什么？

----





