## 形参带默认值的函数（缺省函数）

​	缺省函数调用时可以省去参数表中有默认值的参数省去的部分使用默认值

```cpp
int sum(int a; int b = 10)
{
    return a + b;
}

int main()
{
    sum(0);
}
```

​	此处b就使用默认值0作为参数传入，等价于:

```cpp
sum(0, 10)；
```

​	缺省参数可以有多个但所有缺省参数必须放在参数表的右侧，函数在调用时参数自右向左压栈。

```cpp
sum(0);
//汇编代码为
//mov eax, dword ptr[b]
//push eax
//mov eax, dword ptr[a]
//mov eax
//call sum
```

​	函数缺省时若传入参数为变量时可以节省一次mov eax指令，参数为常数则无区别。

​	缺省值可以选择在声明时给也可以选择在定义时给定，但是默认参数只能给一次，即使两次值相等！

### 小结

​	缺省函数调用时实参个数可以与形参不同

​	函数默认值必须都在右侧

​	缺省值只能给一次

---





## inline 内联函数

### 内联函数声明方式

​	内联函数通过在函数头前冠以inline关键字表明内联属性

~~~cpp
inline <typename> [functionName](parameterTable)
{ Statements }
~~~



### 内联函数与普通函数的区别

​	普通函数调用：

```cpp
int add(int a, int b)
{
    return a + b;
}
int main()
{
    int a = 10;
    int b = 0
    int ret = add(a, b);
}
```

​	调用步骤：
​	函数参数压栈(自右向左)，call指令将下一行代码地址入栈，进入被调用函数，将调用方(此处时main())栈底地址入栈，给add函数开辟栈帧(VS还会对栈内内存初始化为oxcc)。函数调用完毕按照事先存放的地址依次回退到调用函数。
​	此过程产生的欸外调用开销被称为函数调用开销

​	内联函数调用：
​	内联函数在编译阶段被展开到调用函数中不在栈中调用函数，也就不会产生函数调用开销，此处add相当于

~~~cpp
int ret = a + b;
~~~

​	注意inline只是作为一个建议，并非所有inline函数都会被编译器处理成内联函数，其是否具有内联属性由编译器决定。

### inline函数使用原则

​	inline适用于：
​		函数内容少，代码简单，函数功能简单的函数。
​		函数调用频繁，如循环中的函数。

​	inline不适用于：
​		代码量大，功能复杂的函数。
​		递归函数。



---



## 函数重载

​	CPP函数重载允许多个参数表不同的重名函数使用相同的函数
​	函数的函数以参数类型和参数个数作为区分，重载函数不能仅按返回类型做区分。

~~~cpp
int compare(int a, int b);
bool compare(double a, double b);
char compare(char* a, char* b);
~~~

### cpp函数命名与c函数命名方式的区别

​	c函数符号生成时，符号仅由函数名决定。
​	cpp函数符号生成时，符号由函数名和函数参数表类型决定。

​	例如：

~~~c
int sum(int ,int);
~~~

​	在c中产生的符号为sum
​	在cpp中产生的符号为sum_int_int

​	**由于cpp函数符号含有类型信息，因此允许函数重载**	

### 重载的条件

​	**只有在同一作用域的同名函数才拥有重载关系**
​	例如：

~~~cpp
int add(int a, int b)
{
    return a + b;
}
float add(float fa, float fb)
{
    return fa + fb;
}
char add(char a, char b)
{
    return a + b;
}

int main()
{
	int add(int , int );
	add(10, 20);		//1 - 正常运行
    add(0.1f, 0.2f);	//2 - 发生从float->int的转化
    add('a' + 1);		//3 - 发生从char->int的转化
}
~~~

​	int add(int,int)在main函数中有声明，此时它与其他函数不在同一作用域不再构成函数重载，又由于局部优先性，main函数中优先调用 int add(int,int)。其余同名函数被掩盖，发生类型转换。

​	**const和volatitle修饰的参数**
​	const右侧没有 '\*' 不参与类型
​	如const int 和 int 是同种类型，也就无法仅以此构成重载。

### 函数重载是一种静态多态

​	静态多态(编译时确定)：
​		函数重载

​	动态多态(运行时确定)：

### CPP代码，C代码互相调用

​	前文提到C和CPP文件的符号生成方式不同，因此cpp文件和c文件不可以直接调用

​	<big>**在cpp文件中使用 extern "C"{...} 使C程序能够调用cpp文件:**</big>
_sum.cpp_

~~~cpp
extern "C"
{
	int sum(int a, int b)
	{
		return a + b;
    }
}
~~~

_main.c_

~~~C
extern sum(int a, int b);

int main()
{
	sum(10, 20);
}	
~~~

​	也可以在cpp文件时使用cplusplus宏定义
_sum.cpp_

```cpp
#ifdef _cplusplus
extern "C"
{
#endif
    int sum(int a, int b)
    {
        return a + b;
    }
#ifdef _cplusplus
}
#endif
```



​	<big>**在cpp文件的c函数声明中使用 extern "C"{...} 使CPP程序能够调用c文件:**</big>
_sum.c_

~~~cpp
int sum(int a, int b)
{
    return a + b;
}
~~~

_main.cpp_

~~~C
extern "C"
{
	int sum(int,int)
}

int main()
{
    sum(10, 20);      
}
~~~



### 小结

> ​	1.cpp支持重载是因为cpp符号由函数名和参数表确定
> ​	2.只有同一作用域才能称得上函数重载
> ​	3.const和volatile修饰变量有特殊性
> ​	4.函数重载不能仅按返回类型做区分
> ​	5.cpp，c相互调用可以使用extern"c"按照c风格生成符号表
> ​	6.cpp宏 ifdef_cplusplus



---



